<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Reflection" #>
<#@ output extension=".cs" #>

#nullable enable

// DO NOT EDIT THIS FILE!
// it is auto generated via Events.tt

namespace BytingLib
{
<#
    const int MaxParameters = 5;

    string[] eventTypes = new string[]{"Action", "Func"};
    foreach (var EventType in eventTypes)
    {
        bool action = EventType == "Action";
        string eventType = EventType.ToLower();
        string pars = "";
        string parsInner = "";
        string invokePars = "";
        string invokeParsWithoutType = "";
        string _return = action ? "" : "return ";
        int invokeParamCount = 0;
        for (int paramCount = 0; paramCount <= MaxParameters; paramCount++)
        {
            int p = paramCount + 1;

            if (paramCount > 0 || action) // only Action has no param
            {
                string returnTypeWithoutQuestionMark = action ? "void" : ("T" + paramCount);
                string returnType = returnTypeWithoutQuestionMark + (action ? "" : "?");
                #>
            
    public class Event<#=EventType#><#=pars#>
    {
        private event <#=EventType#><#=pars#>? _event;

        public IDisposable Subscribe(<#=EventType#><#=pars#> action)
        {
            _event += action;

            return new EventUnsubscriber(this, action);
        }

        public <#=returnType#> Invoke(<#=invokePars#>)
        {
        <#
                if (action)
                {
                    #>
            <#=_return#>_event?.Invoke(<#=invokeParsWithoutType#>);
                    <#
                }
                else
                {
                    #>
            if (_event == null)
                return default(<#=returnTypeWithoutQuestionMark#>);
            <#=_return#>_event.Invoke(<#=invokeParsWithoutType#>);
                    <#
                }
        #>
        }

        /// <summary>
        /// Should only be called by EventUnsubscriber. Dispose the IDisposable from Subscribe() instead.
        /// </summary>
        private void Unsubscribe(<#=EventType#><#=pars#> action)
        {
            _event -= action;
        }

        private class EventUnsubscriber : IDisposable
        {
            private readonly Event<#=EventType#><#=pars#> _event;
            private readonly <#=EventType#><#=pars#> <#=eventType#>;

            public EventUnsubscriber(Event<#=EventType#><#=pars#> _event, <#=EventType#><#=pars#> <#=eventType#>)
            {
                this._event = _event;
                this.<#=eventType#> = <#=eventType#>;
            }

            public void Dispose()
            {
                _event.Unsubscribe(<#=eventType#>);
            }
        }
    }
                <#
                if (invokePars.Length > 0)
                    invokePars += ", ";
                if (invokeParsWithoutType.Length > 0)
                    invokeParsWithoutType += ", ";

                invokeParamCount++;
                invokePars += "T" + invokeParamCount + " t" + invokeParamCount;
                invokeParsWithoutType += "t" + invokeParamCount;
            }

            if (parsInner.Length > 0)
                parsInner += ", ";
            parsInner += "T" + p;
            pars = "<" + parsInner + ">";
        }
    }
#>

}

#nullable restore